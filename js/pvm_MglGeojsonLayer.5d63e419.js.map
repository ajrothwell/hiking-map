{"version":3,"sources":["webpack:///./node_modules/@phila/vue-mapping/src/mapbox/layer/GeojsonLayer.js"],"names":["name","mixins","computed","filter","this","map","querySourceFeatures","sourceId","geometry","queryRenderedFeatures","layers","layerId","clusterId","Promise","resolve","reject","mapSource","Error","getClusterExpansionZoom","err","zoom","source","getClusterChildren","features","args","getClusterLeaves","$watch","next","initial","theSource","$store","getSource","$props","setData","deep","$_deferredMount","methods","on","$_watchSourceLoading","type","layer","layout","loadImage","$attrs","icon","error","image","addImage","bind","sourcesAlreadyThere","Object","keys","style","sourceCaches","includes","addSource","console","log","replaceSource","removeSource","$_addLayer","$_bindLayerEvents","off","existed","getLayer","replace","$_emitEvent","removeLayer","id","addLayer","before","featureId","state","params","setFeatureState","getFeatureState","sourceLayer","key","removeFeatureState"],"mappings":"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","file":"js/pvm_MglGeojsonLayer.5d63e419.js","sourcesContent":["import layerEvents from \"../lib/layerEvents\";\nimport mixin from \"./layerMixin\";\n\n// const markerDOMEvents = {\n//   click: \"click\",\n//   mouseenter: \"mouseenter\",\n//   mouseleave: \"mouseleave\",\n// };\n\nexport default {\n  name: \"GeojsonLayer\",\n  mixins: [ mixin ],\n\n  computed: {\n    getSourceFeatures() {\n      return filter => {\n        if (this.map) {\n          return this.map.querySourceFeatures(this.sourceId, { filter });\n        }\n        return null;\n      };\n    },\n\n    getRenderedFeatures() {\n      return (geometry, filter) => {\n        if (this.map) {\n          return this.map.queryRenderedFeatures(geometry, {\n            layers: [ this.layerId ],\n            filter,\n          });\n        }\n        return null;\n      };\n    },\n\n    getClusterExpansionZoom() {\n      return clusterId => {\n        return new Promise((resolve, reject) => {\n          if (this.mapSource) {\n            this.mapSource.getClusterExpansionZoom(clusterId, (err, zoom) => {\n              if (err) {\n                return reject(err);\n              }\n              return resolve(zoom);\n            });\n          } else {\n            return reject(\n              new Error(`Map source with id ${this.sourceId} not found.`),\n            );\n          }\n        });\n      };\n    },\n\n    getClusterChildren() {\n      return clusterId => {\n        return new Promise((resolve, reject) => {\n          const source = this.mapSource;\n          if (source) {\n            source.getClusterChildren(clusterId, (err, features) => {\n              if (err) {\n                return reject(err);\n              }\n              return resolve(features);\n            });\n          } else {\n            return reject(\n              new Error(`Map source with id ${this.sourceId} not found.`),\n            );\n          }\n        });\n      };\n    },\n\n    getClusterLeaves() {\n      return (...args) => {\n        return new Promise((resolve, reject) => {\n          if (this.mapSource) {\n            this.mapSource.getClusterLeaves(...args, (err, features) => {\n              if (err) {\n                return reject(err);\n              }\n              return resolve(features);\n            });\n          } else {\n            return reject(\n              new Error(`Map source with id ${this.sourceId} not found.`),\n            );\n          }\n        });\n      };\n    },\n  },\n\n  created() {\n    // console.log('GeojsonLayer.js created is running, this.sourceId:', this.sourceId, 'this.source:', this.source, 'this.$store.map:', this.$store.map);\n    if (this.source) {\n      this.$watch(\n        \"source.data\",\n        function(next) {\n          if (this.initial) {\n            return;\n          }\n          let theSource = this.$store.map.getSource(this.$props.sourceId);\n          // console.log('GeojsonLayer watch source2, this.$store.map:', this.$store.map, 'theSource:', theSource);\n          if (theSource) {\n            theSource.setData(next);\n          }\n        },\n        { deep: true },\n      );\n    }\n    this.$_deferredMount();\n  },\n\n  methods: {\n    $_deferredMount() {\n      // console.log('GeojsonLayer.js $_deferredMount is running, this.map:', this.map, 'this.sourceId:', this.sourceId, 'this.source:', this.source);\n      // this.map = payload.map;\n      // console.log('$_deferredMount, this.map:', this.map);\n      this.map.on(\"dataloading\", this.$_watchSourceLoading);\n      if (this.source) {\n        const source = {\n          type: \"geojson\",\n          ...this.source,\n        };\n        try {\n          // console.log('try map.addSource is starting');\n          if (this.$props.layer.layout['icon-image']) {\n            this.map.loadImage(\n              this.$attrs.icon,\n              function(error, image) {\n                // console.log('inside loadImage, this.$props.layer.layout[icon-image]:', this.$props.layer.layout['icon-image'], 'image:', image, 'this.$attrs.icon:', this.$attrs.icon);\n                this.map.addImage(this.$props.layer.layout['icon-image'], image);\n              }.bind(this),\n            );\n          }\n          let sourcesAlreadyThere = Object.keys(this.map.style.sourceCaches);\n          if (!sourcesAlreadyThere.includes(this.sourceId)) {\n            this.map.addSource(this.sourceId, source);\n          }\n          // console.log('try map.addSource is ending');\n        } catch (err) {\n          console.log('catch err is running, err:', err);\n          if (this.replaceSource) {\n            this.map.removeSource(this.sourceId);\n            this.map.addSource(this.sourceId, source);\n          }\n        }\n      }\n      // console.log('GeojsonLayer.js $_deferredMount, about to $_addLayer');\n      this.$_addLayer();\n      // console.log('GeojsonLayer.js $_deferredMount, after $_addLayer');\n      this.$_bindLayerEvents(layerEvents);\n      this.map.off(\"dataloading\", this.$_watchSourceLoading);\n      this.initial = false;\n    },\n\n    $_addLayer() {\n\n      // this.$_bindMarkerDOMEvents();\n      // console.log('GeojsonLayer.js $_addLayer is starting, this.layerId:', this.layerId);\n      let existed = this.map.getLayer(this.layerId);\n      if (existed) {\n        // console.log('GeojsonLayer.js $_addLayer if existed is running');\n        if (this.replace) {\n          // console.log('if this.replace is true');\n          this.map.removeLayer(this.layerId);\n        } else {\n          this.$_emitEvent(\"layer-exists\", { layerId: this.layerId });\n          return existed;\n        }\n      }\n      // console.log('GeojsonLayer.js $_addLayer is still running, this.layerId:', this.layerId);\n      const layer = {\n        // id: this.layerId,\n        source: this.sourceId,\n        ...this.layer,\n      };\n      layer.id = this.layerId;\n      // console.log('$_addLayer is still running, layer:', layer, 'this.before:', this.before);\n      this.map.addLayer(layer, this.before);\n      // console.log('$_addLayer after map.addLayer');\n      this.$_emitEvent(\"added\", { layerId: this.layerId });\n    },\n\n    // $_emitSelfEvent(event) {\n    //   this.$_emitMapEvent(event, { marker: this.marker });\n    // },\n    //\n    // $_bindMarkerDOMEvents() {\n    //   Object.keys(this.$listeners).forEach(key => {\n    //     if (Object.values(markerDOMEvents).includes(key)) {\n    //       this.marker._element.addEventListener(key, event => {\n    //         this.$_emitSelfEvent(event);\n    //       });\n    //     }\n    //   });\n    // },\n\n    setFeatureState(featureId, state) {\n      if (this.map) {\n        const params = { id: featureId, source: this.source };\n        return this.map.setFeatureState(params, state);\n      }\n    },\n\n    getFeatureState(featureId) {\n      if (this.map) {\n        const params = { id: featureId, source: this.source };\n        return this.map.getFeatureState(params);\n      }\n    },\n\n    removeFeatureState(featureId, sourceLayer, key) {\n      if (this.map) {\n        const params = {\n          id: featureId,\n          source: this.source,\n          sourceLayer,\n        };\n        return this.map.removeFeatureState(params, key);\n      }\n    },\n  },\n};\n"],"sourceRoot":""}